
StampedLock类最主要的存在意义就是为构建一个线程安全的组件提供工具类。因此该类在普通应用
中可能并不常见。

通过以下几种模式获得锁。

Writer-
开发者在该模式下可以互斥地获得该锁。换句话说，在该模式下其他线程不能同时获得同一把锁。

Read-
开发者在该模式下可以以“非互斥”的方式获得锁。不过其他使用写锁模式和乐观读锁模式的线程不能同时获得同一把锁。

readLock Interruptibly(乐观读)
开发者在该模式下并没有真正获得锁。其他线程仍然可以通过读锁模式获得同一把锁。
当开发者希望获得通过乐观读锁保护共享变量时，需要额外检查当前是否可以访问该变量或者不使用validate()方法。

获取锁 返回long值 
【以上所有方法都会返回一个在锁中使用称为票据（stamp）的long型返回值。如果方法返回0，则表示当前线程获取锁失败。】

（readLock()、writeLock()、readLockInterruptibly()）无法获得锁，则当前线程将在获得锁之前保持挂起。
（tryOptimisticRead()、tryReadLock()和tryWriteLock()）无法获得锁，则方法将返回可以表示当前情况的特殊返回值。

返回 lock对象
（asReadLock()、asWriteLock()和asReadWriteLock()）都将返回对应的结果。











这里的锁是临界值嘛？
讲真我只是想提升性能而已..看锁的知识快吐了..